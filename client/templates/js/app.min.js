(function () {
    'use strict';

    angular
        .module('demoApp', [
            'restangular',
            'ngMaterial',
            'ngAnimate',
            'oitozero.ngSweetAlert',
            'md.data.table',
            'demoApp.admin',
            'demoApp.survey'
        ])

        .constant('APP_NAME', 'Civic Solar Project Survey')
        .constant('BASE_URL', window.location.origin)

        .config(['RestangularProvider', function (RestangularProvider) {
            //set the base url for api calls on our RESTful services
            var baseUrl = window.location.origin + '/api';
            RestangularProvider.setBaseUrl(baseUrl);
        }])

        .config(["$mdThemingProvider", function ($mdThemingProvider) {
            $mdThemingProvider.theme('default')
                .primaryPalette('red')
                .accentPalette('pink');
        }]);

}());


(function(){
'use strict';

angular.module('demoApp')
    .factory('HashTable', [HashTable]);

    function HashTable () {

        var uniqueId = 0;

        function generateUniqueId() {
            return (uniqueId++).toString();
        }

        function HashTable() {
            this.hash = {};
        }

        HashTable.prototype.get = function (key) {
            if (typeof key === "string") {
                return this.hash[key];
            }
            if (key._hashtableUniqueId == undefined) {
                return undefined;
            }
            return this.hash[key._hashtableUniqueId];
        }

        HashTable.prototype.put = function (key, value) {
            if (typeof key === "string") {
                this.hash[key] = value;
            }
            else {
                if (key._hashtableUniqueId == undefined) {
                    key._hashtableUniqueId = generateUniqueId();
                }
                this.hash[key._hashtableUniqueId] = value;
            }
        }

        HashTable.prototype.clear = function () {
            this.hash = {};
        }

        return (HashTable);
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('utilServices', [utilServices]);

    function utilServices () {
        var service = {};

        var hexChar = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

        service.getFormData = getFormData;
        service.setScopeValue = setScopeValue;
        service.byteToHex = byteToHex;

        /**
         * Formats the results of $(form).serializeArray() from
         * [{name:"", value:""},{}...] into {name1:value1, name2:value2, ...}
         * @param form
         * @returns {{}}
         */
        function getFormData(form) {
            var unindexed_array = form.serializeArray();
            var indexed_array = {};

            _.map(unindexed_array, function (n, i) {
                indexed_array[n['name']] = n['value'];
            });

            return indexed_array;
        }

        /**
         * Iteratively finds a model inside a scope and sets its value.
         * E.g. setScopeValue($scope, 'scip.sections.scip_files.file_usgs_topo_map', 1)
         * @param $scope
         * @param model_name
         * @param value
         */
        function setScopeValue($scope, model_name, value) {
            var names = model_name.split('.');
            var data = $scope;
            var name = "";
            for (var i = 0; i < names.length; i++) {
                name = names[i];
                if (_.has(data, name)) {
                    if (i < names.length - 1)
                        data = data[name];
                    else
                        data[name] = value;
                } else {
                    if (i < names.length - 1)
                        break;
                    else
                        data[name] = value;
                }
            }
        }

        /**
         * 0-255 to 00-ff
         * @param b
         */
        function byteToHex(b) {
            return hexChar[(b >> 4) & 0x0f] + hexChar[b & 0x0f];
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('modalServices', ['$q', '$mdDialog', '$mdMedia', '$rootScope', modalServices]);

    function modalServices($q, $mdDialog, $mdMedia, $rootScope) {
        var service = {};

        //var customFullscreen = $mdMedia('xs') || $mdMedia('sm');

        var addProjectModal,
            projectDetailModal
        ;

        /* Service Functions */
        service.showAddProject = showAddProject;
        service.showProjectDetail = showProjectDetail;
        service.hideResolveModal = hideResolveModal;
        service.closeModal = closeModal;

        function showModal(modalObj, modalParams) {
            var dfd = $q.defer();
            if (modalObj) {
                dfd.reject("Modal already opened");
            } else {
                $rootScope.$broadcast("modal-opened");
                modalObj = $mdDialog.show(modalParams);
                modalObj.then(function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        modalObj = null;
                    });
            }
            return dfd.promise;
        }

        function showAddProject(ev, selectedPosition, address) {
            var opts = {
                controller: 'addProjectController',
                controllerAs: 'vm',
                templateUrl: '/projects/add',
                //parent: angular.element(document.body),
                parent: angular.element(document.querySelector('#index-container')),
                targetEvent: ev,
                locals: {position: selectedPosition, positionAddress: address},
                fullscreen: $mdMedia('lg')
            };
            return showModal(addProjectModal, opts);
        }

        function showProjectDetail(proj) {
            var opts = {
                controller: 'projectDetailsController',
                //controllerAs: 'vm',
                templateUrl: '/projects/edit',
                //parent: angular.element(document.body),
                parent: angular.element(document.querySelector('#index-container')),
                locals: {project: proj},
                //fullscreen: $mdMedia('lg')
                //hasBackdrop: false,
                //onComplete: function (scope, element, options) {
                //    $('.md-scroll-mask').css('z-index', '0');
                //}
            };
            return showModal(projectDetailModal, opts);
        }

        function hideResolveModal (response) {
            $mdDialog.hide(response);
        }

        // Close Modal
        function closeModal() {
            $mdDialog.cancel();
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('loaderServices', ['$rootScope', loaderServices]);

    function loaderServices ($rootScope) {
        var service = {};

        service.showLoader = showLoader;
        service.hideLoader = hideLoader;

        function showLoader () {
            $rootScope.spinner.active = true;
        }

        function hideLoader (_doApply) {
            var doApply = _doApply || false;
            if(doApply) {
                $rootScope.$apply(function () {
                    $rootScope.spinner.active = false;
                });
            } else {
                $rootScope.spinner.active = false;
            }
        }
        

        return service;
    }
}());
(function(){
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', gmapServices]);

    function gmapServices($log, $q) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 6;
        service.ZOOM_IN_LEVEL = 17;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_OUT_LEVEL;

        service.defaultLatLng = new google.maps.LatLng(41.878114, -87.629798);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.initializeGeocoder = initializeGeocoder;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;

        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId) {
            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.defaultLatLng,
                mapTypeId: google.maps.MapTypeId.MAP,
                //mapTypeControlOptions: {
                //    position: google.maps.ControlPosition.TOP_LEFT
                //},
                mapTypeControl: false,
                zoomControlOptions: {
                    position: google.maps.ControlPosition.LEFT_BOTTOM
                },
                panControl: false,
                streetViewControl: false
            };

            $(myMapId).height($(window).height() - (42));

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // initialize geocoder
            //initializeGeocoder();

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (42));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function initializeGeocoder () {
            if(!service.apiAvailable() || service.geocoder) return;
            service.geocoder = new google.maps.Geocoder();
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if( !(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function(infobox, index) {
               if(infobox) {
                   infobox.close();
               }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            _color = _color || service.MARKER_ICONS.RED;
            var marker = service.initMarker(_position, _color);

            service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            var marker = service.initMarker(_position, icon);
            service.markers.push(marker);

            return marker;
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if(_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else{
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach( function(marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.defaultLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if(!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, _color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: strokeColor,
                fillOpacity: 0,
                strokeColor: strokeColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polygon(polygonOptions);
        }

        function createPolygon(path, _color) {
            var polygon = service.initPolygon(path, _color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach( function(path){
                bounds.extend(path);
            });

            service.panTo(bounds.getCenter());
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            service.initializeGeocoder();

            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if(layerName == 'meters') {
                return defaultStyle;
            } else if(layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if(layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId) {
            var input = document.getElementById(elementId);
            var autocomplete = new google.maps.places.Autocomplete(input, {
                types: ["geocode"]
            });

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation (latLng, polygon) {
            if(!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent (obj, event) {
            google.maps.event.trigger(obj, 'click');
        }

        return service;
    }
}());


(function () {
'use strict';

angular.module('demoApp')
    .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showBottomLeftToast = showBottomLeftToast;
        service.showTopRightToast = showTopRightToast;
        service.showNoDataAvailablePrompt = showNoDataAvailablePrompt;
        service.showEntityNotFound = showEntityNotFound;
        service.showFilterSelectionEmpty = showFilterSelectionEmpty;
        service.showQueryIsEmpty = showQueryIsEmpty;

        function showToast(message, position) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position(position)
                    .hideDelay(2000)
            );
        }

        function showBottomLeftToast(message) {
            showToast(message, 'bottom left');
        }

        function showTopRightToast(message) {
            showToast(message, 'top right');
        }

        function showMessage(message, type) {
            SweetAlert.swal({
                title: message,
                type: type
            });
        }

        function showNoDataAvailablePrompt (entityName) {
            service.showBottomLeftToast('No '+ entityName +' data available for this area.');
        }

        function showEntityNotFound(entityName) {
            showMessage(entityName + ' not found.', 'warning');
        }

        function showFilterSelectionEmpty() {
            showMessage('Please select filter type.', 'warning');
        }

        function showQueryIsEmpty () {
            showMessage('Please fill in search query.', 'info');
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('surveyLocationServices', ['$q', 'locationServices', 'gmapServices', '$timeout', surveyLocationServices]);

    function surveyLocationServices ($q, locationServices, gmapServices, $timeout) {
        var service = {};

        var locationMarkerIcon = 'images/markers/current-location.png';
        var locationMarker = null;

        service.locationAddress = '';

        service.showSurveyLocationMarker = showSurveyLocationMarker;
        service.hideSurveyLocationMarker = hideSurveyLocationMarker;
        service.getCurrentLocation = getCurrentLocation;
        service.dropAndPointSurveyLocation = dropAndPointSurveyLocation;
        service.getLocation = getLocation;

        function positionSurveyLocationMarker (position) {
            if (!locationMarker) {
                locationMarker = gmapServices.createCustomMarker(position, locationMarkerIcon);
            } else {
                if (!locationMarker.getMap()) gmapServices.showMarker(locationMarker);
                locationMarker.setPosition(position);
            }
        }

        function hideSurveyLocationMarker () {
            if(locationMarker && locationMarker.getMap()) {
                locationMarker.setMap(null);
                locationMarker = null;
            }
        }


        function initSurveyLocationMarker(position) {
            positionSurveyLocationMarker(position);

            $timeout(function () {
                gmapServices.panTo(position);
                gmapServices.setZoomIfGreater(20);
            }, 100);
        }

        service.geocodeLocation = geocodeLocation;

        function geocodeLocation () {
            var dfd = $q.defer();

            gmapServices.reverseGeocode(locationMarker.getPosition())
                .then(function (response) {
                    dfd.resolve(response);
                    //service.locationAddress = response[0].formatted_address;
                }, function(error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function showSurveyLocationMarker (position, address) {
            if(address) service.locationAddress = address;

            initSurveyLocationMarker(position);
        }

        function getCurrentLocation () {
            var dfd = $q.defer();

            locationServices.getCurrentLocation()
                .then(function (response) {
                    var position = {lat: response.coords.latitude, lng: response.coords.longitude};
                    showSurveyLocationMarker(position);
                    dfd.resolve(response);
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function dropAndPointSurveyLocation () {
            positionSurveyLocationMarker(gmapServices.map.getCenter());
            locationMarker.setDraggable(true);
        }

        function getLocation () {
            if (locationMarker && locationMarker.getMap()) {
                var position = locationMarker.getPosition();
                //geocodeLocation(position);
                return position;
            }

            return false;
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.survey', ['ngFileUpload']);

}());


(function(){
'use strict';

angular.module('demoApp.survey')
    .controller('projectDetailsController', ['project', '$scope', '$q', '$controller', 'modalServices', 'utilServices', projectDetailsController]);

    function projectDetailsController (project, $scope, $q, $controller, modalServices, utilServices) {
        $controller('errorController', {$scope: $scope});

        $scope.project = {
            id: 0
        };

        $scope.initialize = initialize;
        $scope.save = save;
        $scope.close = close;

        $scope.initialize();

        function initialize () {
            //console.log('selectedProject: ',project);

            // Fixes bug on WTForms SelectField
            if(project.project_manager) project.project_manager.id = String(project.project_manager.id);
            if(project.contractor) project.contractor.id = String(project.contractor.id);
            if(project.civicsolar_account_manager) project.civicsolar_account_manager.id = String(project.civicsolar_account_manager.id);

            $scope.project = project;
        }


        function saveSections () {
            // Get all <form> elements under id='project-detail-content'
            var forms = $("#project-detail-content form");
            var projectData = {};
            var formData = {};
            for (var i = 0; i < forms.length; i++) {
                var disabledFields = $(forms[i]).find(':input:disabled').removeAttr('disabled');
                var data = utilServices.getFormData($(forms[i]));
                if (forms[i].name == "project_info") {
                    projectData = data;
                }
                else
                    formData[forms[i].name] = data;

                disabledFields.attr('disabled', 'disabled');
            }
            projectData["sections"] = formData;

            var dfd = $q.defer();

            console.log('projectData: ', projectData);

            $scope.project.customPOST(projectData, 'sections') //($scope.project.id, projectData)
                .then(function (response) {
                    $scope.project.date_modified = response.date_modified;
                    dfd.resolve(response);
                },function (response) {
                    dfd.reject(response);
                });
            return dfd.promise;
        }


        function postToServer() {
            var dfd = $q.defer();

            // This is a chained save sequence.
            // We'll be saving SCIPSections first.
            // Failure on any of the requests will break the sequence and halt saving.
            var onFail = function (response, model, prefix) {
                console.log(response);
                if (response && response.errors) {
                    $scope.showErrorAlerts(response.errors, model, prefix);
                }
                else
                    console.log(response);
                dfd.reject(response);
            };
            var onComplete = function (response) {
                console.log(response);
                dfd.resolve(response);
            };

            $scope.errors.clear();
            $scope.project.numErrors = 0;

            saveSections()
                .then(function (response) {
                    return onComplete(response);
                }, function (response) {
                    onFail(response, $scope.project, 'project');
                });

            return dfd.promise;
        }



        function save () {
            // Todo: show loading animation

            postToServer()
                .then(function(response){
                    // resolve dismiss modal
                    modalServices.hideResolveModal(response);
                },function(errorResponse){
                    // TODO: show Errors
                })
                .finally(function(){
                    // TODO: hide loading animation
                });
        }

        // todo
        $scope.fileChanged = function(files, rejectedFiles) {
        };

        // todo
        $scope.filePreview = function(modelName) {
        };

        function close () {
            modalServices.closeModal();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp.survey')
    .factory('projectsServices', ['$rootScope', 'gmapServices', 'modalServices', '$timeout', projectsServices]);

    function projectsServices ($rootScope, gmapServices, modalServices, $timeout) {
        var service = {};

        var markers = [];

        service.hideMarkers = hideMarkers;
        service.showMarkers = showMarkers;
        service.initializeMarkers = initializeMarkers;
        service.showProjectDetail = showProjectDetail;
        service.findMarkerByProjectID = findMarkerByProjectID;
        service.findAndShowMarker = findAndShowMarker;
        service.findAndShowProjectDetail = findAndShowProjectDetail;

        function hideMarkers() {
            if (!markers || markers.length <= 0) return;
            gmapServices.hideMarkers(markers);
            // Close any infowindow
            gmapServices.closeAllInfoBox();
        }

        function showMarkers() {
            if (!markers || markers.length <= 0) return;
            gmapServices.showMarkers(markers);
        }

        function initializeMarkers(projects) {
            if (projects == null || projects == 'undefined') {
                service.hideMarkers();
                return;
            }

            // Close any infowindow
            gmapServices.closeAllInfoBox();

            for (var i = 0; i < markers.length || i < projects.length; i++) {
                var proj = projects[i];

                if (i >= markers.length) {
                    var marker = gmapServices.createCustomMarker(proj.coordinates);
                    marker.infowindow = initInfowindow(proj);
                    marker.id = proj.id;
                    marker.project = proj;
                    markers.push(marker);
                    gmapServices.addListener(marker, 'click', onClickMarker);
                }
                else if (i >= projects.length) {
                    if (markers[i])  markers[i].project = null;
                    gmapServices.hideMarker(markers[i]);
                }
                else if (markers[i]) {
                    markers[i].id = proj.id;
                    markers[i].project = proj;
                    markers[i].setPosition(proj.coordinates);
                    gmapServices.showMarker(markers[i]);
                }
            }
        }

        function onClickMarker() {
            gmapServices.openInfoBox(this.infowindow, this);
            gmapServices.panTo(this.getPosition());

            // this refers to clicked marker
            $rootScope.selectedProject = this.project;
        }

        function showProjectDetail (proj) {
            if (!(proj && proj.id)) return;

            service.hideMarkers();

            proj.get().
            then(
                function(response){
                    modalServices.showProjectDetail(response)
                        .then(function (response) {
                            if (!response) return;
                            if ($rootScope.selectedProject && response) $rootScope.selectedProject.coordinates = response.coordinates;
                        }, function (errorResponse) {
                            console.log('show update solar detail failed');
                            console.log(errorResponse);
                        })
                        .finally(function () {
                            gmapServices.setZoomDefault();
                            service.showMarkers();
                        });
                }, function(error){
                    console.log('get project details error: ',error);
                });

        }

        function initInfowindow(proj) {
            var template = createInfowindowTemplate(proj);
            return gmapServices.createInfoBox(template);
        }

        function createInfowindowTemplate(proj) {
            return '<div class="marker_info none" id="marker_info">' +
                '<div class="info" id="info">' +
                '<h4>' + proj.project_name + '<span></span></h4>' +
                '<p>' + (proj.contractor ? proj.contractor.name : 'Unassigned') + '</p>' +
                '<a href="#!" class="infowindow_btn btn_view_project_detail">More info</a>' +
                '<span class="arrow"></span>' +
                '</div>' +
                '</div>';
        }

        function findMarkerByProjectID (projectID) {
            var foundMarker = _.findWhere(markers, {id: projectID});
            return foundMarker;
        }

        function findAndShowMarker (projectID) {
            var foundMarker = service.findMarkerByProjectID(projectID);
            gmapServices.triggerEvent(foundMarker, 'click');
        }

        function findAndShowProjectDetail (projectID) {
            $timeout(function(){
                service.findAndShowMarker(projectID);
            }, 100)
            .then(function(){
                $timeout(function(){
                    $('a.btn_view_project_detail').trigger('click');
                }, 100);
            });
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular
        .module('demoApp.admin', ['ng.jsoneditor']);

}());


(function () {
    'use strict';

    angular.module('demoApp.admin')
        .factory('Projects', ['Restangular', Projects]);

    function Projects(Restangular) {
        var myModel = Restangular.all('projects');

        var resource = {
            cast: function (obj) {
                return Restangular.restangularizeElement(null, obj, 'projects');
            }
        };

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.survey')
        .factory('locationServices', ['$q', 'gmapServices', locationServices]);

    function locationServices($q, gmapServices) {
        var service = {};

        function getError(error) {
            var errors = {
                1: 'Permission denied',
                2: 'Position unavailable',
                3: 'Request timeout'
            };
            return "Error: " + errors[error.code];
        }

        service.getCurrentLocation = function () {
            var dfd = $q.defer();

            if (!navigator.geolocation) {
                dfd.reject('Browser doesnt support Geolocation');
                return dfd.promise;
            }

            var getPositionSuccess = function (position) {
                dfd.resolve(position);
            };

            var getPositionError = function (error) {
                console.log('getPositionError: ',error);
                dfd.reject(getError(error));
            };

            navigator.geolocation.getCurrentPosition(getPositionSuccess, getPositionError, {enableHighAccuracy: true});

            return dfd.promise;
        };

        // Parameter must be a latLng
        service.showCurrentLocation = function (position) {
            var latLng = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };
            var marker = gmapServices.showCurrentLocation(latLng);
            var offset = 0.002;


            gmapServices.panToOffsetLeft(latLng, offset);
            gmapServices.setZoomInDefault();

            return marker;
        };

        service.showDraggableLocation = function () {
            var draggable = true,
                latLng = gmapServices.map.getCenter();

            var marker = gmapServices.showCurrentLocation(latLng, draggable);

            //gmapServices.panToOffsetLeft(latLng);

            return marker;
        };

        return service;
    }

}());
(function(){
'use strict';

angular.module('demoApp.survey')
    .controller('addressSearchController', ['gmapServices', 'surveyLocationServices', addressSearchController]);

    function addressSearchController (gmapServices, surveyLocationServices) {
        var vm = this;

        var autocomplete;

        vm.initialize = initialize;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            autocomplete = gmapServices.initializeAutocomplete('address-search-input');
            autocomplete.addListener('place_changed', placeChangeCallback);
        }

        function placeChangeCallback() {
            var place = autocomplete.getPlace();

            if (!place.geometry) {
                alert("Autocomplete's returned place contains no geometry");
                return;
            }

            surveyLocationServices.showSurveyLocationMarker(place.geometry.location, place.formatted_address);
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp.survey')
    .controller('addProjectController', ['$scope', '$controller', 'modalServices', 'Projects', 'position', 'positionAddress', addProjectController]);

    function addProjectController ($scope, $controller, modalServices, Projects, position, positionAddress) {
        var vm = this;

        // Inherit all error handling methods from errorController
        $controller('errorController', {$scope: $scope});
        //$controller('validationController', {$scope: $scope});

        $scope.project = {};

        vm.initialize = initialize;
        vm.save = save;
        vm.close = close;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $scope.project.coordinates = position.toJSON();
            $scope.project.project_address = positionAddress;
        }

        function save () {
            console.log('project: ', $scope.project);

            Projects.post($scope.project)
                .then(function(response){
                    var restangularizedProject = Projects.cast(response.project);
                    // dismiss modal
                    modalServices.hideResolveModal(restangularizedProject);
                },function(errorResponse){
                    console.log('error adding project: ', errorResponse);

                    // TODO: show Errors
                    if(errorResponse.data.errors) {
                        $scope.showErrorAlerts(errorResponse.data.errors, $scope.project, 'project');
                    }
                });
        }

        function close () {
            modalServices.closeModal();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('validationController', ['$scope', 'utilServices', validationController]);

    function validationController ($scope, utilServices) {

        //$scope.onTextChanged = function (model, modelName, value) {
        //    console.log("{0} changed value to {1}".format(modelName, value));
        //    if (modelName.endsWith(".latitude") || modelName.endsWith(".longitude")) {
        //        $scope.validateLatLng(model, modelName, value);
        //    } else if (modelName.endsWith(".lease_area_size")) {
        //        $scope.validateLeaseAreaSize(model, modelName, value);
        //    }
        //};

        $scope.validateLatLng = function (model, modelName, value) {
            var data = ("" + value).trim();
            var components = [];
            if (/^(\-*\d+\-\d+\-\d+(\.\d+)*)$/.test(data)) {
                // deg-min-secs e.g. 30-24-42
                components = data.split('-');
                // if first number is negative, shift values to left and
                // treat all components as negative (e.g. -91-51-42)
                if (components.length == 4) {
                    for (var i = 1; i < components.length; i++)
                        components[i - 1] = parseFloat(components[i]) * -1.0;
                    components.splice(components.length - 1, 1);
                }
            } else if (/^(\-*\d+\ \d+\ \d+(\.\d+)*)$/.test(data)) {
                // deg min secs e.g. 30 24 42
                components = data.split(' ');
                // if first number is negative, make all components negative
                // e.g. (-98 03 46.16)
                if (components[0].indexOf('-') >= 0) {
                    for (var i = 1; i < components.length; i++)
                        components[i] = parseFloat(components[i]) * -1.0;
                }
            }
            if (components.length == 3) {
                var degrees = parseFloat(components[0]) +
                    parseFloat(components[1]) / 60.0 + parseFloat(components[2]) / 3600.0;
                var childName = modelName.slice(modelName.indexOf('.') + 1, modelName.length);
                utilServices.setScopeValue(model, childName, degrees.toFixed(6));
                $scope.removeError(model, modelName);
            } else if (/^(\-*\d+(\.\d+)*)$/.test(data)) {
                // degrees in decimal e.g. 30.2124234
                $scope.removeError(model, modelName);
            } else {
                // invalid data format
                $scope.putError(model, modelName, "Invalid number");
            }
        };

        $scope.validateLeaseAreaSize = function (model, modelName, value) {
            var data = ("" + value).trim();
            if (/^(\d+\s*[x]\d+)$/.test(data)) {
                // number x number e.g. 30x10 is auto-converted to 300
                var components = data.split('x');
                var totalArea = parseInt(components[0].trim()) * parseInt(components[1].trim());
                utilServices.setScopeValue($scope, modelName, totalArea);
                $scope.removeError(model, modelName);
            } else if (/^(\d+)$/.test(data)) {
                $scope.removeError(model, modelName);
            } else {
                $scope.putError(model, modelName, "Invalid number");
            }
        };

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('projectListController', ['$rootScope', '$scope', 'projectsServices', projectListController]);

    function projectListController($rootScope, $scope, projectsServices) {
        var vm = this;

        vm.projects = [];

        vm.query = {
            order: 'status',
            limit: 10,
            page: 1,
            filter: ''
        };

        vm.filter = {
            show: false,
            form: null
        };

        vm.searchFilters = {
            project_status: "",
            project_name: "",
            project_manager: {fullname: ""},
            contractor: {name: ""},
            civicsolar_account_manager: {fullname: ""}
        };

        vm.initialize = initialize;
        vm.close = close;
        vm.onClickRow = onClickRow;
        vm.showProjectDetails = showProjectDetails;
        vm.onReorder = onReorder;
        vm.removeFilter = removeFilter;

        vm.initialize();

        function initialize() {
            $scope.$watch(angular.bind(vm, function () {
                return vm.query.filter;
            }), startFilter);

            $rootScope.$watchCollection('projects', function(newValue){
                loadProjects(newValue);
            });
        }

        /* Table Functions */

        function onReorder() {}

        function removeFilter() {
            vm.filter.show = false;
            vm.query.filter = '';
            if (vm.filter.form.$dirty) vm.filter.form.$setPristine();
        }

        function onClickRow(project) {
            projectsServices.findAndShowMarker(project.id);
        }

        function showProjectDetails(proj) {
            projectsServices.findAndShowProjectDetail(proj.id);

        }

        function loadProjects(project) {
            vm.projects = angular.copy(project);
            filterList();
        }

        function startFilter() {
            vm.query.filter = vm.query.filter.toLowerCase();

            for (var key in vm.searchFilters)
                if (vm.searchFilters.hasOwnProperty(key))
                    vm.searchFilters[key] = vm.query.filter;

            filterList();
        }

        function filterList() {
            if (isEmptyFilter())
                vm.projects = angular.copy($rootScope.projects);
            else {
                var filtered = manualFilter(vm.searchFilters);
                vm.projects = filtered;
            }
        }

        function manualFilter(searchFilters) {
            var result = [];
            vm.projects.forEach(function (lot) {
                for (var key in searchFilters) {
                    var lotData = String(lot[key]).toLowerCase();
                    if (lotData.indexOf(vm.query.filter) !== -1) {
                        result.push(lot);
                        return;
                    }
                }
            });
            return result;
        }

        function isEmptyFilter() {
            return vm.query.filter === '';
        }

        function close() {
            $mdDialog.hide();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('mainController', ['$rootScope', 'APP_NAME', '$mdSidenav', mainController]);

    function mainController ($rootScope, APP_NAME, $mdSidenav) {
        var vm = this;

        $rootScope.appName = APP_NAME;

        /* Side Nav Menus */
        vm.menu = [
            {
                link: '/admin',
                title: 'Admin',
                icon: 'contacts'
            },
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app'
            }
        ];

        vm.toggleMainMenu = buildToggler('mainMenuSidenav');

        /* Non Scope Functions here */
        function buildToggler(navID) {
            return function () {
                $mdSidenav(navID)
                    .toggle()
                    .then(function () {
                        console.log("toggle " + navID + " is done");
                    });
            }
        }
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('layerController', [layerController]);

    function layerController() {
        var vm = this;

        vm.layers = [
            {
                label: 'Layer1',
                action: 'layerCtl.toggleLayer1()',
                selected: false
            },
            {
                label: 'Layer2',
                action: 'layerCtl.toggleLayer2()',
                selected: false
            },
            {
                label: 'LayerWithChildren1',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child1-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child1-2',
                        selected: false,
                        action: ''
                    }
                ]
            },
            {
                label: 'LayerWithChildren2',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child2-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child2-2',
                        selected: false,
                        action: ''
                    }
                ]
            }
        ];


        vm.toggleLayer1 = toggleLayer1;
        vm.toggleLayer2 = toggleLayer2;


        function toggleLayer1 () {
            if (vm.layers[0].selected) {
                console.log('turn on layer1');
            } else {
                console.log('turn off layer1');
            }
        }

        function toggleLayer2 () {
            if (vm.layers[1].selected) {
                console.log('turn on layer2');
            } else {
                console.log('turn off layer2');
            }
        }
        /* Non Scope Functions here */

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('indexController', ['$rootScope', 'Projects', '$mdSidenav', indexController]);

    function indexController($rootScope, Projects, $mdSidenav) {
        var vm = this;

        $rootScope.projects = [];

        vm.showList = false;

        vm.initialize = initialize;
        vm.toggleLayerPanel = buildToggler('layerPanel');
        vm.toggleSearchPanel = buildToggler('searchPanel');
        vm.closeSideNav = closeSideNav;

        vm.lastSideNavOpenId = '';

        vm.initialize();

        function initialize() {
            // load all projects here
            Projects.getList()
                .then(function(response){
                    console.log('get projects: ',response);
                    response.forEach(function(p){
                       $rootScope.projects.push(p);
                    });
                },function(error){
                    console.log('get projects error: ', error);
                });
        }

        function buildToggler(navID) {
            return function () {
                if (vm.lastSideNavOpenId && vm.lastSideNavOpenId !== navID) {
                    closeSideNav(vm.lastSideNavOpenId);
                }

                $mdSidenav(navID).toggle();

                vm.lastSideNavOpenId = navID;
            }
        }

        function closeSideNav(navID) {
            $mdSidenav(navID).close();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('gmapController', ['$rootScope', 'gmapServices', 'surveyLocationServices', 'modalServices', 'projectsServices', 'alertServices', gmapController]);

    function gmapController($rootScope, gmapServices, surveyLocationServices, modalServices, projectsServices, alertServices) {

        var vm = this;

        vm.showSaveLocationBtn = false;
        vm.showAddressSearchContainer = false;

        vm.initialize = initialize;
        vm.getCurrentLocation = getCurrentLocation;
        vm.showAddressSearch = showAddressSearch;
        vm.dropLocation = dropLocation;
        vm.saveLocation = saveLocation;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('map-canvas');

            $rootScope.$watchCollection('projects', loadProjects);

            /*
             *  Trigger a modal
             *  show Project Detail
             */
            $(document).on('click', '.btn_view_project_detail', function () {
                //$rootScope.solarDetailSelectedTab = 0;
                projectsServices.showProjectDetail($rootScope.selectedProject);
            });
        }

        function loadProjects (newValue, oldValue) {
            if(newValue == oldValue) return;
            projectsServices.initializeMarkers(newValue);
        }

        function getCurrentLocation () {
            hideAddressBar();

            surveyLocationServices.getCurrentLocation()
                .then(function(response){
                    showLocationButton();
                    console.log('success: ',response);
                }, function(error){
                    console.log('error: ',error);
                });
        }

        function dropLocation () {
            hideAddressBar();
            showLocationButton();

            alertServices.showTopRightToast('Drag Marker to Relocate');

            surveyLocationServices.dropAndPointSurveyLocation();
        }

        function showAddressSearch () {
            showLocationButton();
            vm.showAddressSearchContainer = true;
        }

        function hideAddressBar() {
            if (vm.showAddressSearchContainer) vm.showAddressSearchContainer = false;
        }

        function showLocationButton () {
            vm.showSaveLocationBtn = true;
        }

        function hideLocationButton () {
            vm.showSaveLocationBtn = false;
        }

        function saveLocation (event) {
            hideLocationButton();

            var selectedPosition = surveyLocationServices.getLocation();

            surveyLocationServices.geocodeLocation()
                .then(function(response){
                    // show modal here
                    modalServices.showAddProject(event, selectedPosition, response[0].formatted_address)
                        .then(function(response){
                            // add project to list on rootScope
                            $rootScope.projects.push(response);
                        })
                        .finally(function () {
                            surveyLocationServices.hideSurveyLocationMarker();
                        });
                });
        }
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('filterController', ['gmapServices', 'alertServices', filterController]);

    function filterController(gmapServices, alertServices) {
        var vm = this;

        vm.filterLayer = '';

        var searchMarker = null;
        var searchInfowindow = null;

        var autocomplete = null;

        vm.initialize = initialize;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            autocomplete = gmapServices.initializeAutocomplete('filter-location-input');

            autocomplete.addListener('place_changed', placeChangeCallback);
        }


        //function showResult(data) {
        //    if (!searchInfowindow) searchInfowindow = gmapServices.createInfoWindow('');
        //
        //    if (!searchMarker) {
        //        searchMarker = gmapServices.createCustomMarker(data.coordinates);
        //    } else {
        //        if (!searchMarker.getMap()) gmapServices.showMarker(searchMarker);
        //
        //        searchMarker.setPosition(data.coordinates);
        //    }
        //
        //    searchInfowindow.setContent(data.content);
        //
        //    gmapServices.addListener(searchMarker, 'click', function () {
        //        searchInfowindow.open(gmapServices.map, searchMarker);
        //    });
        //
        //    gmapServices.triggerEvent(searchMarker, 'click');
        //}
        //
        //function hideSearchMarker() {
        //    if (searchMarker && searchMarker.getMap()) {
        //        gmapServices.hideMarker(searchMarker);
        //    }
        //}

        function placeChangeCallback() {
            var place = autocomplete.getPlace();
            if (!place.geometry) {
                alert("Autocomplete's returned place contains no geometry");
                return;
            }
            //console.log('Place Changed!', place);
            // If the place has a geometry, then present it on a map.
            if (place.geometry.viewport) {
                gmapServices.map.fitBounds(place.geometry.viewport);
            } else {
                gmapServices.map.setCenter(place.geometry.location);
                gmapServices.map.setZoom(15);
            }
        }


        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('errorController', ['$scope', 'HashTable', errorController]);

    function errorController ($scope, HashTable) {
        $scope.errors = new HashTable();

        /**
         * Map of errors come in two formats:
         * 1) errors[field] = {"0":"msg1", "1":"msg2", ...}
         *  - These are errors for model data
         *      (e.g. scip.project_name, candidate.latitude)
         * 2) errors[section][field] = ["msg1", "msg2", ...]
         *  - These are errors for model sections and their fields
         *      (e.g. scip.sections.scip_info.location_name, candidate.sections.zoning_info.area_size)
         *
         * @param errors - Associative array (map) containing error messages for each fields
         * @param model  - Contains the JS Object for our DBModel
         * @param prefix - Contains the name of our parent model (e.g. "scip", "candidate")
         */
        $scope.showErrorAlerts = function (errors, model, prefix) {
            console.log('show error alerts: ', errors);
            var alerts = {};
            var numErrors = 0;

            model.errors = {};

            for (var section in errors) {
                for (var field in errors[section]) {
                    if (field !== '0') {
                        var modelName = [prefix, 'sections', section, field].join('.');
                        var error = errors[section][field];
                        alerts[modelName] = error[error.length - 1];
                        numErrors++;
                    } else {
                        var modelName = [prefix, section].join('.');
                        var error = errors[section];
                        alerts[modelName] = error[error.length - 1];
                        numErrors++;
                        break;
                    }
                }

                var errStr = '';
                errors[section].forEach(function(err){
                    errStr += err + '\n'
                });
                model.errors[section] = errStr;
            }

            $scope.errors.put(model, alerts);
            console.log('modal: ', model);
            model.numErrors = numErrors;
        };

        $scope.setErrorTooltip = function (model, modelName) {
            $scope.errorTooltip = $scope.getError(model, modelName);
        };

        $scope.putError = function (model, modelName, error) {
            var alerts = $scope.errors.get(model);
            if (!alerts) alerts = {};
            alerts[modelName] = error;
            $scope.errors.put(model, alerts);
        };

        $scope.removeError = function (model, modelName) {
            var alerts = $scope.errors.get(model);
            if (alerts && modelName in alerts) {
                delete alerts[modelName];
                $scope.errors.put(alerts);
            }
        };

        $scope.hasError = function (model, modelName) {
            var alerts = $scope.errors.get(model);
            if (alerts == undefined || alerts[modelName] == undefined)
                return false;
            return true;
        };

        $scope.getError = function (model, modelName) {
            var alerts = $scope.errors.get(model);
            if (alerts && _.has(alerts, modelName))
                return alerts[modelName];
            return undefined;
        };

    }
}());
(function(){
'use strict';

angular.module('demoApp.admin')
    .factory('Users', ['Restangular', Users]);

    function Users(Restangular) {
        var myModel = Restangular.all('users');

        var resource = {
            cast: function (obj) {
                return Restangular.restangularizeElement(null, obj, 'users');
            }
        };

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.admin')
    .controller('userManagementController', ['Users', userManagementController]);

    function userManagementController (Users) {
        var vm = this;

        vm.users = [];

        vm.initialize = initialize;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            // fetch users
            Users.getList()
                .then(function(response){
                    //console.log('get users: ', response);
                    vm.users = angular.copy(response);
                });
        }

        /* Non Scope Functions here */

    }
}());
(function () {
    'use strict';

    angular.module('demoApp.admin')
        .factory('FormSchemas', ['Restangular', FormSchemas]);

    function FormSchemas(Restangular) {
        var myModel = Restangular.all('form_schemas');

        var resource = {
            cast: function (obj) {
                return Restangular.restangularizeElement(null, obj, 'form_schemas');
            }
        };

        angular.merge(myModel, resource);

        return myModel;
    }
}());
(function(){
'use strict';

angular.module('demoApp.admin')
    .factory('formSchemaServices', ['FormSchemas', formSchemaServices]);

    function formSchemaServices (FormSchemas) {
        var service = {};

        service.getSchemas = getSchemas;
        service.saveSchema = saveSchema;

        function getSchemas () {
            return FormSchemas.getList();
        }

        function saveSchema (file) {
            return FormSchemas.customPOST(file.data, file.name);
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp.admin')
        .controller('formSchemaController', ['formSchemaServices', 'alertServices', formSchemaController]);

    function formSchemaController(formSchemaServices, alertServices) {
        var vm = this;

        vm.jsonFiles = [];

        vm.jsonEditor = {
            data: null,
            options: {
                mode: 'tree'
            }
        };

        var lastSelectedFile = null,
            selectedFile = null;


        vm.initialize = initialize;
        vm.selectFile = selectFile;
        vm.saveCurrentFile = saveCurrentFile;
        vm.saveAllFiles = saveAllFiles;
        vm.refresh = refresh;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            loadSchemas();
        }

        function selectFile(file) {
            if(lastSelectedFile) lastSelectedFile.active = false;
            if (selectedFile && vm.jsonEditor.data) selectedFile.data = vm.jsonEditor.data;

            selectedFile = file;
            selectedFile.active = true;
            vm.jsonEditor.data = selectedFile.data;

            lastSelectedFile = selectedFile;
        }

        function loadSchemas () {
            return formSchemaServices.getSchemas()
                .then(function(response){
                    vm.jsonFiles = angular.copy(response);
                    if (vm.jsonFiles &&  vm.jsonFiles.length > 0)
                        selectFile(vm.jsonFiles[0]);
                });
        }

        function saveCurrentFile() {
            var file = _.findWhere(vm.jsonFiles, {active: true});
            if (file) {
                file.data = vm.jsonEditor.data;
                formSchemaServices.saveSchema(file)
                    .then(function (response) {
                        alertServices.showTopRightToast('Current File Saved.');
                    }, function (response) {
                        console.log('failed to save current file');
                    });
            }
        }

        function saveAllFiles () {
            var index = 0;

            var doFail = function () {
                console.log('failed saving all files');
            };

            var doSave = function () {
                if (index < vm.jsonFiles.length) {
                    var file = vm.jsonFiles[index++];
                    return formSchemaServices.saveSchema(file).then(doSave, doFail);
                } else {
                    alertServices.showTopRightToast('All Files Saved.');
                    return null;
                }
            };

            var file = _.findWhere(vm.jsonFiles, {active: true});
            if (file) file.data = vm.jsonEditor.data;
            doSave();
        }

        function refresh () {
            loadSchemas()
                .finally(function(){
                    alertServices.showTopRightToast('Done Refresh.');
                });
        }

    }
}());